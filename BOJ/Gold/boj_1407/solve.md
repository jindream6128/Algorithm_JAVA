# 1407번 : 2로 몇 번 나누어 떨어질까 (Gold4)
[주소](https://www.acmicpc.net/problem/1407)

## solve
f(x) -> x 하나에 대해서만 구하면 안된다
f(x) -> 0부터 x미만까지 구하던가 한번에 해야된다
이게 기본 IDEA라고 할 수 있고

dp(x) -> x를 넣었을 때 0부터 x미만까지 합한 값을 구해야 됨
이걸 어떻게??

잘 모르겠으니 1부터 적어보면서 규칙을 찾는다

1  0001 (1)
2  0010 (2)
3  0011 (1)
4  0100 (4)
5  0101 (1) == 0001
6  0110 (2) == 0010
7  0111 (1) == 0011
8  1000 (8)
9  1001 (1)
10 1010 (2)
11 1011 (1)
12 1100 (4)
13 1101 (1) == 0001
14 1110 (2) == 0010
15 1111 (1) == 0011
16 10000 (16)
... // 17~31은 결국 1~15랑 똑같음. 따라서 *2하여 이 부분은 계산 생략?이 가능하다.
32 100000 dp(100000) -> dp(16) * 2 + 16

오른쪽의 0의 갯수가 2로 나눌 수 있는 횟수가 되는걸 발견할 수 있다.

dp(0b1000) -> dp(0b0100) * 2 + 0b0100
dp(0b10000) -> dp(0b1000) * 2 + 0b1000

// n은 2의 제곱수만 넣어야 한다.
solveOnly2(n) -> dp(n) + n

18 -> solveOnly2(16) + solveOnly2(2)
21 -> solveOnly2(16) + solveOnly2(4) + solveOnly2(1)

2의 제곱수의 합으로 나타내는 법은 이진수로 보았을 때 1로 되어있는 부분들이다
18 -> 10010
21 -> 10101 (10000 + 00100 + 00001)
      00100

n // 구하려는 수 ex) 21
part = 1 // 2의 제곱수이다 이건 1, 10, 100 이런식으로 늘어남
answer = 0;
while (true) {
  if (part > n) break;

  // 비트 연산자로 part 라는 2의 제곱수를 가지고 있는지 확인할 수 있다.
  // and 해봤을 때 0이 아니면 겹치는게 있는거니까
  // part를 가지고 있다고 볼 수 있다.
  // 여기서 n & part 하는거는 0이 아닌수가 나오는거는 2의 제곱수를 가지고 있는거다.

  if ((n & part) != 0) {
    answer += solveOnly2(part);
  }
  part *= 2;
}

## 분류

- 수학